<div class="lection">
    <div class="section-name">Основы операционных систем</div>

    <h1>Лекция 2: "Управление реальной памятью"</h1>

    <h2>Введение</h2>

    <p>Управление памятью, наряду с управлением процессами и ресурсами, - одна из наиболее важных функций операционной системы. Задача ОС заключается в том, чтобы размещать в памяти пользовательские процессы, их данные, обслуживать запросы процессов на области памяти заданных размеров. В данной лекции рассмотрены базовые понятия и механизмы, связанные с управлением памятью, в частности, этапы загрузки программ в память и их связывание с адресами в памяти. Две основные стратегии управления памятью – страничная организация и сегментная организация – рассмотрены в следующих двух лекциях "Страничная организация памяти" и "Сегментная организация памяти" .</p>

    <h2>Основные положения размещения процессов в памяти</h2>

    <p>Любая программа, введенная в систему, должна быть размещена в памяти и оформлена в виде процесса для ее выполнения. Каждая программа при вводе в систему помещается во входную очередь – совокупность процессов на диске, ожидающих размещения в памяти для выполнения своих программ. До своего выполнения пользовательские программы проходят в системе несколько стадий.</p>

    <h2>Связывание программ и данных с адресами в памяти</h2>

    <p>Перед загрузкой данных или кода в память они должны быть в какой-либо момент связаны с определенными адресами в памяти. Связывание может выполняться на разных этапах:</p>

    <p>*<b>Связывание во время компиляции (compile-time)</b>.Если адрес в памяти априорно известен, компилятором может быть сгенерирован код с абсолютными адресами. При любом изменении размещения программы в памяти должна быть выполнена перекомпиляция. Данный подход более характерен для ранних компьютерных систем с небольшим объемом памяти, либо для обработки и выполнения системных модулей – частей ядра ОС, для которых характерно использование резидентных абсолютных адресов. Для пользовательских программ такой подход неудобен, так как не обеспечивает достаточной гибкости, в частности, возможности без изменений перезагрузить код в другую область памяти.</p>
    <p>*<b>Связывание во время загрузки (load-time)</b>.Загрузка программы в память – стадия ее обработки системой, предшествующая выполнению программы. Чтобы начальный адрес области памяти, куда загружается программа, можно было менять, и это не привело бы к необходимости изменения кода программы, применяется следующий метод. Генерируется перемещаемый код (relocatable code) – код, в котором адресация происходит относительно значения регистра перемещения (relocation register),и адрес в памяти равен сумме значения регистра перемещения и адреса, вычисляемого в команде. Таким образом, при необходимости загрузки кода на другое место в памяти требуется изменить только значение регистра перемещения. Подобный подход широко используется для программ, написанных на традиционных языках программирования.</p>
    <p>*<b>Связывание во время исполнения (runtime),или динамическое (позднее)</b> связывание.Используется, если процесс во время выполнения может быть перемещен из одного сегмента памяти в другой. Для реализации связывания во время исполнения требуется аппаратная поддержка отображения адресов – например, регистры базы и границы. В большинстве систем для пользовательских программ используется, главным образом, именно связывание во время исполнения.</p>

    <h2>Многоэтапная обработка пользовательской программы</h2>

    <p>Чтобы лучше представлять себе все детали адресации и размещения программы в памяти, рассмотрим общую схему многоэтапной обработки пользовательской программы, используемую в любой ОС.</p>

    <img src="15_1sm.png" alt="img">
    <p><b>Рис 1.1</b> (Многоэтапная обработка пользовательской программы)</p>
    
    <p><b> Исходный код </b> программы (в форме текстового файла) на языке высокого уровня или на ассемблере преобразуется компилятором или ассемблером в объектный модуль, содержащий бинарные выполняемые машинные команды и таблицу символов, определенных и использованных в данном модуле кода. Рассмотренная фаза называется временем компиляции.</p>
    
    <p>Однако объектный модуль не может непосредственно исполняться, так как он содержит неразрешенные ссылки на внешние модули и их компоненты. Следующая фаза обработки программы – редактирование связей. Редактор связей (linker) – системная программа, которая получает на вход один или несколько объектных модулей, а на выходе выдает загрузочный модуль – двоичный код, образованный кодом нескольких объектных модулей, в котором разрешены все межмодульные ссылки - для каждого символа, внешнего для данного объектного модуля A, найден соответствующий символ (процедуры, переменной и т.д.) из другого модуля B, на который ссылается модуль A, и код соответственно откорректирован, т.е. он правильно адресует внешний символ.</p>
    
    <P>Загрузочный модуль может быть загружен в память для исполнения с помощью еще одной системной программы – загрузчика (loader),который получает на вход загрузочный модуль и файлы с бинарными кодами системных библиотек,которые использует программа. Загрузчик, объединяя код программы с кодами системных библиотек, создает бинарный образ программы в памяти.</P>
    
    <P>Фаза вызова редактора связей и загрузчика носит общее название время загрузки. Во многих ОС функции редактора связей и загрузчика, с целью экономии времени обработки программы в системе, объединены в одной системной программе – редакторе связей и загрузчике (linker and loader).Например, в системе UNIX редактор связей и загрузчик называется ld (Linker and loaDer).Объединенному загрузчику и редактору связей на вход передается список объектных модулей и список библиотек, и в результате он генерирует исполняемый код. Фаза редактирования связей и загрузки часто на программистском слэнге называется линковкой (linking).Будем далее использовать именно этот короткий и выразительный термин.</P>

    <div class="quest">
        <h3>*Вопрос по лекции*?</h3>
        <div class="answers">
            <div class="answer-box">
                <label for="answ1">Вариант ответа №1</label>
                <input type="radio" name="answer1" id="answ1">
            </div>
            <div class="answer-box">
                <label for="answ1">Вариант ответа №2</label>
                <input type="radio" name="answer1" id="answ2">
            </div>
            <div class="answer-box">
                <label for="answ1">Вариант ответа №3</label>
                <input type="radio" name="answer1" id="answ3">
            </div>
            <div class="answer-box">
                <label for="answ1">Вариант ответа №4</label>
                <input type="radio" name="answer1" id="answ4">
            </div>
        </div>
        
        <input class="submit" type="submit" value="Подтвердить">
    </div>
    <a href="includes/lection_handler.php?section=oper_sys&topic=machine_depend&page=lection&num=2"><button class="complete-btn">Продолжить</button></a>
</div>