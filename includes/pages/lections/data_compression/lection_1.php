<div class="lection">
    <div class="section-name">Основы операционных систем</div>

    <h1>Лекция 1: "Сжатие информации"</h1>

    <p>Цель сжатия - уменьшение количества бит, необходимых для хранения или передачи заданной информации, что дает возможность передавать сообщения более быстро и хранить более экономно и оперативно (последнее означает, что операция извлечения данной информации с устройства ее хранения будет проходить быстрее, что возможно, если скорость распаковки данных выше скорости считывания данных с носителя информации). Сжатие позволяет, например, записать больше информации на дискету, "увеличить" размер жесткого диска, ускорить работу с модемом и т.д. При работе с компьютерами широко используются программы-архиваторы данных формата ZIP, GZ, ARJ и других. Методы сжатия информации были разработаны как математическая теория, которая долгое время (до первой половины 80-х годов), мало использовалась в компьютерах на практике.</p>

    <p>Сжатие данных не может быть большим некоторого теоретического предела. Для формального определения этого предела рассматриваем любое информационное сообщение длины n как последовательность независимых, одинаково распределенных д.с.в. X_i или как выборки длины n значений одной д.с.в. X.

Доказано1 что среднее количество бит, приходящихся на одно кодируемое значение д.с.в., не может быть меньшим, чем энтропия этой д.с.в., т.е. ML(X) \ge HX для любой д.с.в. X и любого ее кода.

Кроме того, Доказано2 утверждение о том, что существует такое кодирование (Шеннона-Фэно, Fano), что HX \ge ML(X)-1.

Рассмотрим д.с.в. X_1 и X_2, независимые и одинаково распределенные. HX_1 = HX_2 и I(X_1,X_2) = 0, следовательно,

H(X_1,X_2)= HX_1+HX_2-I(X_1,X_2)=2HX_1.
Вместо X_1 и X_2 можно говорить о двумерной д.с.в. \vec X=(X_1,X_2). Аналогичным образом для n -мерной д.с.в. \vec X=(X_1,X_2,\ldots,X_n) можно получить, что H\vec
X=nHX_1.
Пусть L_1(\vec X)=L(\vec X)/n, где \vec X =
(X_1,X_2,\ldots,X_n), т.е. L_1(\vec X) - это количество бит кода на единицу сообщения \vec X. Тогда ML_1(\vec X) - это среднее количество бит кода на единицу сообщения при передаче бесконечного множества сообщений \vec X. Из ML(\vec X)-1 \le H\vec X \le ML(\vec X) для кода Шеннона-Фэно для \vec X следует ML_1(\vec X)-1/n \le HX_1 \le ML_1(\vec
X) для этого же кода.</p>
    
    <p>Таким образом, доказана основная теорема о кодировании при отсутствии помех, а именно то, что с ростом длины n сообщения, при кодировании методом Шеннона-Фэно всего сообщения целиком среднее количество бит на единицу сообщения будет сколь угодно мало отличаться от энтропии единицы сообщения. Подобное кодирование практически не реализуемо из-за того, что с ростом длины сообщения трудоемкость построения этого кода становится недопустимо большой. Кроме того, такое кодирование делает невозможным отправку сообщения по частям, что необходимо для непрерывных процессов передачи данных. Дополнительным недостатком этого способа кодирования является необходимость отправки или хранения собственно полученного кода вместе с его исходной длиной, что снижает эффект от сжатия. На практике для повышения степени сжатия используют метод блокирования.</p>
    
    <p>По выбранному значению \varepsilon>0 можно выбрать такое s, что если разбить все сообщение на блоки длиной s (всего будет n/s блоков), то кодированием Шеннона-Фэно таких блоков, рассматриваемых как единицы сообщения, можно сделать среднее количество бит на единицу сообщения большим энтропии менее, чем на \varepsilon. Действительно, пусть \vec Y=(\vec Y_1,\vec Y_2,\ldots,\vec Y_{n/s}), \vec Y_1=(X_1,X_2,\ldots,X_s), \vec<br>
Y_2=(X_{s+1},X_{s+2},\ldots,X_{2s}) и т.д., т.е. \vec Y_i=(X_{s(i-1)+1},X_{s(i-1)+2},\ldots,X_{si}). Тогда H\vec Y_1=sHX_1 и sML_1(\vec Y_1)=ML(\vec Y_1) \le H\vec<br>
Y_1+1 = sHX_1+1, следовательно, <br>
<br>
ML_1(\vec Y_1) \le HX_1 + 1/s,<br>
т.е. достаточно брать s=1/\varepsilon. Минимум s по заданному \varepsilon может быть гораздо меньшим 1/\varepsilon.<br>
Пример. Пусть д.с.в. X_1,X_2,\ldots X_n независимы, одинаково распределены и могут принимать только два значения P(X_i=0)=p=3/4 и P(X_i=1)=q=1/4 при i от 1 до n. Тогда<br>
<br>
HX_i={3\over4}\log_2{4\over3}+{1\over4}\log_24=2-{3\over4}\log_23<br>
\approx0.811 \hbox{ бит/сим}.<br>
Минимальное кодирование здесь - это коды 0 и 1 с длиной 1 бит каждый. При таком кодировании количество бит в среднем на единицу сообщения равно 1. Разобьем сообщение на блоки длины 2. Закон распределения вероятностей и кодирование для 2-мерной д.с.в. \vec X=(X_1,X_2) -<br>
\smallskip<br>
\centerline{\vbox{\offinterlineskip<br>
\halign{&\strut\quad\hfil#\hfil& \vrule#\cr<br>
$\vec X$       && 00   && 01   && 10   && 11\cr<br>
\noalign{\hrule}<br>
$p$            && 9/16 && 3/16 && 3/16 && 1/16\cr<br>
$code(\vec X)$ && 0    &&10   && 110  && 111\cr<br>
$L(\vec X)$    && 1    && 2    && 3    && 3.\cr}}}<br>
\smallskip<br>
Тогда при таком минимальном кодировании количество бит в среднем на единицу сообщения будет уже<br>
<br>
ML_1(\vec<br>
X)=\bigl(1{9\over16}+2{3\over16}+3{3\over16}+3{1\over16}\bigr)/2=<br>
{27\over32}=0.84375,<br>
т.е. меньше, чем для неблочного кодирования. Для блоков длины 3 количество бит в среднем на единицу сообщения можно сделать \approx0.823, для блоков длины 4 - \approx0.818 и т.д.<br>
Все изложенное ранее подразумевало, что рассматриваемые д.с.в. кодируются только двумя значениями (обычно 0 и 1). Пусть д.с.в. кодируются m значениями. Тогда для д.с.в. \vec X и любого ее кодирования верно, что ML(\vec X) \ge H\vec X/\log_2m и ML_1(\vec X) \ge HX_1/\log_2m. Кроме того, существует кодирование такое, что ML(\vec X)-1 \le H\vec<br>
X/\log_2m и ML_1(\vec X)-1/n \le HX_1/\log_2m, где n=\dim(\vec<br>
X).<br>
<br>
Формулы теоретических пределов уровня сжатия, рассмотренные ранее, задают предел для средней длины кода на единицу сообщений, передаваемых много раз, т.е. они ничего не говорят о нижней границе уровня сжатия, которая может достигаться на некоторых сообщениях и быть меньшей энтропии д.с.в., реализующей сообщение.</p>


    <div class="quest">
        <h3>*Вопрос по лекции*?</h3>
        <div class="answers">
            <div class="answer-box">
                <label for="answ1">Вариант ответа №1</label>
                <input type="radio" name="answer1" id="answ1">
            </div>
            <div class="answer-box">
                <label for="answ1">Вариант ответа №2</label>
                <input type="radio" name="answer1" id="answ2">
            </div>
            <div class="answer-box">
                <label for="answ1">Вариант ответа №3</label>
                <input type="radio" name="answer1" id="answ3">
            </div>
            <div class="answer-box">
                <label for="answ1">Вариант ответа №4</label>
                <input type="radio" name="answer1" id="answ4">
            </div>
        </div>
        
        <input class="submit" type="submit" value="Подтвердить">
    </div>
    <<a href="includes/lection_handler.php?section=oper_sys&topic=data_compression&page=lection&num=1"><button class="complete-btn">Продолжить</button></a>
</div>